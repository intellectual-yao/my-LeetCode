// Source : https://leetcode.cn/problems/permutations/
// Author : GuoQiang Yao
// Date : 2022-6-5
/**************************************************************************************
给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

示例 1：

输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
示例 2：

输入：nums = [0,1]
输出：[[0,1],[1,0]]
示例 3：

输入：nums = [1]
输出：[[1]]

提示：

1 <= nums.length <= 6
-10 <= nums[i] <= 10
nums 中的所有整数 互不相同
**************************************************************************************/

/*******************************************************************************************************
题目分析： 本题可以采用深度优先（二叉树）的方式来进行所有可能的排列情况的遍历，比如，
给定的数字是1，2，3；那么，我们首先考虑 1 开头的排列，那么之后的数字要么是 2 要么是 3 ，
如果第二个数字选择2，那么第三个数字只能选择3，反之，第三个数字只能选择2；然后我们去考虑第一个数字为 1 的情况，
原理与之前相同，因为我们需要在走到叶子节点的时候进行返回，因此需要一个撤销操作，树的深度就是给定数组的长度，
因此递归的终止条件就是当变量走到len的大小的时候进行停止，然后进行的操作是将元素依次放入结果数组中。
********************************************************************************************************/

class Solution {
public:
    void backtrack(vector<vector<int>> &res, vector<int> output, int first, int len)
    {
        // 如果当前已经到了叶子节点，说明所有的数字均被放入，需要回溯了
        if(first == len)
        {
            res.push_back(output);
            return; 
        }
        for(int i = first;i < len;++i)
        {
            // 数字交换
            swap(output[i], output[first]);
            // 递归放入下一个数字
            backtrack(res, output, first + 1, len);
            // 因为要返回上一层节点，因此需要将开始的操作进行撤销
            swap(output[i], output[first]);
        }
    }

    vector<vector<int>> permute(vector<int>& nums) 
    {
        vector<vector<int>> res;
        backtrack(res, nums, 0, nums.size());
        return res;
    }
}; 
