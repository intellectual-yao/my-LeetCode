// Source : https://leetcode.cn/problems/maximum-product-subarray/
// Author : GuoQiang Yao
// Date : 2022-10-28
/**************************************************************************************
给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个 32-位 整数。

子数组 是数组的连续子序列。

示例 1:

输入: nums = [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
示例 2:

输入: nums = [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。

提示:

1 <= nums.length <= 2 * 104
-10 <= nums[i] <= 10
nums 的任何前缀或后缀的乘积都 保证 是一个 32-位 整数 　　
**************************************************************************************/

/*******************************************************************************************************
题目分析 : 典型的DP问题，f[i]表示以num[i]结尾的连续子数组的最大乘积，那么可以分为两种情况，
如果数组只有一个元素的话，那么f[i] = num[s]，反之，f[i] = f[i - 1] * num[i]，
即本问题转化成了以num[i - 1]结尾的连续子数组的最大值与当前位置元素的乘积。最后的结果就是从二者中选择值较大的哪个，
即状态转移方程为：f[i] = max(f[i - 1] * num[i], num[i])。
此方法存在一个问题，即如果数组中存在负数的话会导致最大值乘以负数会使得变为最小值或者当前的最小值乘以负数以后变为最大值，
因此我们在结果中也需要维护一个最小值（负数）。此时假设数组中含有负数，g[i]表示以num[i]结尾的连续子数组乘积的最小值。
此时存在两种情况如果num[i] > 0，那么之前分析的状态转移方程不变，f[i] = max(f[i - 1] * num[i], num[i])。如果Num[i] < 0，
那么此时的状态转移方程为f[i] = max(num[i], g[i - 1] * num[i])，即最小值乘以一个负数变成最大值。
所以最大值的状态转移方程为：f[i] = max(num[i], max(f[i - 1] * num[i], g[i - 1] * num[i]))。
因为前面用到了g[i - 1]，因此需要对最小值的状态转移方程进行表示。还是从num[i]的值进行考虑，当num[i] >= 0，
与最大值的考虑方式一样，只需要把max改为min即可，即g[i] = min(num[i], g[i - 1] * num[i])，如果Num[i] < 0，
如果只有一个数的话，那么最小值就是num[i]，如果有多个元素的话就是前num[i - 1]的最大值乘以当前位置的数据，
即g[i] = min(num[i], f[i - 1] * num[i])
所以最小值的状态转移方程为：g[i] = mix(num[i], min(g[i - 1] * num[i], f[i - 1] * num[i]))。
初始状态：num[0] = 0 = f[0] = g[0]
********************************************************************************************************/

class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int size = nums.size(), res = nums[0];
        // 最值数组初始化
        vector<int> f(size + 1, 0), g(size + 1, 0);
        f[0] = nums[0], g[0] = nums[0];
        for(int i = 1;i < size;++i)
        {
            f[i] = max(nums[i], max(f[i - 1] * nums[i], g[i - 1] * nums[i]));
            g[i] = min(nums[i], min(f[i - 1] * nums[i], g[i - 1] * nums[i]));
            res = max(res, f[i]);
        }
        return res;
    }
};
