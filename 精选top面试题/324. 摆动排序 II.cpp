// Source :https://leetcode.cn/problems/wiggle-sort-ii/
// Author : GuoQiang Yao
// Date : 2022-12-4
/**************************************************************************************
给你一个整数数组 nums，将它重新排列成 nums[0] < nums[1] > nums[2] < nums[3]… 的顺序。

你可以假设所有输入数组都可以得到满足题目要求的结果。

示例 1：

输入：nums = [1,5,1,1,6,4]
输出：[1,6,1,5,1,4]
解释：[1,4,1,5,1,6] 同样是符合题目要求的结果，可以被判题程序接受。
示例 2：

输入：nums = [1,3,2,2,3,1]
输出：[2,3,1,3,1,2]

提示：

1 <= nums.length <= 5 * 104
0 <= nums[i] <= 5000
题目数据保证，对于给定的输入 nums ，总能产生满足题目要求的结果

进阶：你能用 O(n) 时间复杂度和 / 或原地 O(1) 额外空间来实现吗？
**************************************************************************************/

/*******************************************************************************************************
题目分析：本题使用额外的数组空间，首先将数组复制，然后对新数组进行排序，在排好序的数组中，
找到中间位置的前一个元素和最后一个元素的下标位置，可以发现排序好的数组的前半部分一定大于后半部分，
因此可以利用这两个位置的元素依次进行向前遍历，然后对之前的数组进行赋值，这样原先的数组的元素就会被全部替换为目的数组的样子，从而完成解答。
********************************************************************************************************/

class Solution {
public:
    void wiggleSort(vector<int>& nums) {
        vector<int> res = nums;
        // 排序链表
        sort(res.begin(), res.end());
        int left = (nums.size() - 1) / 2, right = nums.size() - 1;
        for(int i = 0;i < nums.size();++i)
        {
            // 偶数小，奇数大
            if(i % 2 == 0)
            {
                nums[i] = res[left];
                --left;
            }
            else
            {
                nums[i] = res[right];
                --right;
            }
        }
    }
}; 
