// Source : https://leetcode.cn/problems/powx-n/
// Author : GuoQiang Yao
// Date : 2022-6-12
/**************************************************************************************
实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn ）。

示例 1：

输入：x = 2.00000, n = 10
输出：1024.00000
示例 2：

输入：x = 2.10000, n = 3
输出：9.26100
示例 3：

输入：x = 2.00000, n = -2
输出：0.25000
解释：2-2 = 1/22 = 1/4 = 0.25

提示：

-100.0 < x < 100.0
-2^31 <= n <= 2^31-1
-10^4 <= xn <= 10^4
**************************************************************************************/

/*******************************************************************************************************
题目分析：本题在分析清楚乘方的原理之后进行计算的话倒是代码比较简单，但存在的问题就是会导致超时，
因为时间复杂度为O(n)，因此需要降低时间复杂度，这里我们以2的8次方为例，2^8， 2^4， 2^2， 2^1，
可以想到使用递归，然后处理当n为0的情况。如果幂次小于0的话需要进行分数操作。
********************************************************************************************************/

// 本方法超时
// class Solution {
// public:
//     // 计算一个数字n次幂的方法
//     double my_cal(double x, int n)
//     {
//         double temp = 1.0;
//         for(int i = 0;i < n;++i)
//         {
//             temp *= x;
//         }
//         return temp;
//     }
//     double myPow(double x, int n) {
//         double res;
//         if(x == 1)
//             return 1.0;
//         if(n > 0)
//             return my_cal(x, n);
//         else if(n < 0)
//         {
//             // 如果幂次小于0的话首先将幂次转为正数
//             n = abs(n);
//             // 将x转为对应的分数
//             x = 1 / x;
//             res = my_cal(x, n);
//         }
//         else
//             return 1.0;
//         return res;
//     }
// };
class Solution {
public:
    double quickM(double x, int n)
    {
        // 如果幂次为0的话就返回1.0
        if(n == 0)
            return 1.0;
        double temp = quickM(x, n / 2);
        // 如果幂次为奇数的话需要在结果之后再乘原来的数字
        return n % 2 == 0 ? temp * temp : temp * temp * x;
    }
    double myPow(double x, int n) {
        int tem = n;
        return tem > 0 ? quickM(x, n) : 1.0 / quickM(x, abs(tem));
    }
}; 
