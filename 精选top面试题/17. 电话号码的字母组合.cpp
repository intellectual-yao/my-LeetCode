// Source : https://leetcode.cn/problems/letter-combinations-of-a-phone-number/
// Author : GuoQiang Yao
// Date : 2022-5-30
/**************************************************************************************
给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。


给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

示例 1：

输入：digits = “23”
输出：[“ad”,“ae”,“af”,“bd”,“be”,“bf”,“cd”,“ce”,“cf”]
示例 2：

输入：digits = “”
输出：[]
示例 3：

输入：digits = “2”
输出：[“a”,“b”,“c”]

提示：

0 <= digits.length <= 4
digits[i] 是范围 [‘2’, ‘9’] 的一个数字。
**************************************************************************************/

/*******************************************************************************************************
题目分析： 最容易想到的方法就是我首先遍历当前数字在哈希表中对应的字符串中的第一个字符，
然后在这个字符的基础上遍历下一个数字对应的字符串的全部字母，然后组合起来，如果走到叶子节点，
就将当前字符串加入到结果字符串中。本题难点在于使用递归进行计算并且需要对回溯的方法进行考虑即在走到叶子节点的时候要将当前位置的元素抛出以完成回溯。
********************************************************************************************************/

class Solution {
public:
    // 键值对进行保存
    map<char, string> M = {{'2', "abc"}, {'3', "def"}, {'4', "ghi"}, 
    {'5', "jkl"}, {'6', "mno"}, {'7', "pqrs"}, {'8', "tuv"}, {'9', "wxyz"}};
    vector<string> res;
    string temp;
    void DFS(int index, string digits)
    {
        // 递归的结束条件处理
        if(index == digits.size())
        {
            res.push_back(temp);
            return;
        }
        // 对当前的数字，拿出对应的字母
        for(int i = 0;i < M[digits[index]].size();++i)
        {
            // 先将数字对应的第一个字符存放在临时的字符串中
            temp.push_back(M[digits[index]][i]);
            // 以这个数字为根，向下继续列举子树
            // 例如给出的是digits = 23,那么遍历完2对应的某个字符后要选3对应字符的其中一个进行遍历
            DFS(index + 1, digits);
            // 比如现在是ad,那么应该抛出d，继续遍历ae
            temp.pop_back();
        }
    }
    vector<string> letterCombinations(string digits) {
        if(digits.size() == 0)
            return res;
        DFS(0, digits);
        return res;
    }
}; 
