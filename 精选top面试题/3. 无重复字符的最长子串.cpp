// Source : https://leetcode.cn/problems/longest-substring-without-repeating-characters/
// Author : GuoQiang Yao
// Date : 2022-5-25

/**************************************************************************************
给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。

示例 1:

输入: s = “abcabcbb”
输出: 3
解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。
示例 2:

输入: s = “bbbbb”
输出: 1
解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。
示例 3:

输入: s = “pwwkew”
输出: 3
解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。
请注意，你的答案必须是 子串 的长度，“pwke” 是一个子序列，不是子串。

提示：

0 <= s.length <= 5 * 104
s 由英文字母、数字、符号和空格组成
**************************************************************************************/

/*******************************************************************************************************
题目分析： 比较容易想到的是暴力法,使用两个指针向后遍历,如果朋友左右指针的元素相同的话就将左指针移动到
相同元素的左侧的元素的下一个位置,此方法时间复杂度为平方级,小编使用哈希表,每次加入元素之后就在哈希表中查找,
如果不存在的话说明不重复,否则需要将左侧的下标移动到重复元素左侧的元素的下一个位置,此外,无论是否移动left指针,
均需要将右指针向右移动一位然后将右侧元素的下标存储起来,每次移动完之后将最大值进行保存,这里使用max()函数即可,
只有当两个指针的间隔长度大于res的时候才应该将结果值进行更新.
********************************************************************************************************/

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int s_size = s.size();
        int left = 0, right = 0, length = 0, res = 0;
        unordered_map<char, int> hash;
        while(right < s_size)
        {
            char temp = s[right];
            // 如果当前字符没有在哈希表中出现并且当前字符的位置大于等于左游标
            if(hash.find(temp) != hash.end() && hash[temp] >= left)
            {
                // 左游标应该更新至重复字符的后一位
                left = hash[temp] + 1;
                length = right - left;
            }
            hash[temp] = right;
            ++right;
            ++length;
            // 保存最大值
            res = max(length, res);
        }
        return res;
    }
}; 
