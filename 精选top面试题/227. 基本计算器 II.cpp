// Source :https://leetcode.cn/problems/basic-calculator-ii/
// Author : GuoQiang Yao 
// Date : 2022-11-20
/**************************************************************************************
给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。

整数除法仅保留整数部分。

你可以假设给定的表达式总是有效的。所有中间结果将在 [-231, 231 - 1] 的范围内。

注意：不允许使用任何将字符串作为数学表达式计算的内置函数，比如 eval() 。

示例 1：

输入：s = “3+2*2”
输出：7
示例 2：

输入：s = " 3/2 "
输出：1
示例 3：

输入：s = " 3+5 / 2 "
输出：5

提示：

1 <= s.length <= 3 * 105
s 由整数和算符 (‘+’, ‘-’, ‘*’, ‘/’) 组成，中间由一些空格隔开
s 表示一个 有效表达式
表达式中的所有整数都是非负整数，且在范围 [0, 231 - 1] 内
题目数据保证答案是一个 32-bit 整数
**************************************************************************************/

/*******************************************************************************************************
题目分析：当碰到数字或者字符的时候进行不同的操作，碰到操作符的时候将操作数进行对应的操作，可以将每个元素进行相应的操作，
若读到一个运算符，或者遍历到字符串末尾，即认为是遍历到了数字末尾。处理完该数字后，更新flag为当前遍历的字符。
为了首先将第一个元素放入，因此初始化flag为+,每次读取运算符之后需要将当前运算数通过运算符进行计算，然后将结果保存在结果数组，
最后将结果数组的所有元素相加即可得到最终结果。
********************************************************************************************************/

class Solution {
public:
    int calculate(string s) {
        // 最终将结果数组中的所有元素相加，即可得到结果
        vector<int> res;
        char flag = '+';
        int num = 0;
        for(int i = 0;i < s.size();++i)
        {
            // 如果是数字的话就将其从字符转化为数字
            // 如果只输入一个二维数据，那么需要乘10操作
            if(isdigit(s[i]))
                num = num * 10 + int(s[i] - '0');
            // 最后一个数字也要放入求和数组，因此if最后一个条件是必须的
            if(!isdigit(s[i]) && s[i] != ' ' || i == s.size() - 1)
            {
                switch(flag)
                {
                    case '+':
                        res.push_back(num);
                        break;
                    case '-':
                        res.push_back(-num);
                        break;
                    case '*':
                        res.back() *= num;
                        break;
                    default:
                        res.back() /= num;
                        break;
                }
                num = 0;
                flag = s[i];
            }
        }
        return accumulate(res.begin(), res.end(), 0);
    }
};
