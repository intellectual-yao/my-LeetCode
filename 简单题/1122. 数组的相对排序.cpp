// Source : https://leetcode-cn.com/problems/relative-sort-array/
// Author : GuoQiang Yao
// Date : 2022-3-19

/**************************************************************************************
给你两个数组，arr1 和 arr2，arr2 中的元素各不相同，arr2 中的每个元素都出现在 arr1 中。

对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。

示例 1：

输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
输出：[2,2,2,1,4,3,3,9,6,7,19]
示例 2:

输入：arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6]
输出：[22,28,8,6,17,44]

提示：

1 <= arr1.length, arr2.length <= 1000
0 <= arr1[i], arr2[i] <= 1000
arr2 中的元素 arr2[i] 各不相同
arr2 中的每个元素 arr2[i] 都出现在 arr1 中

**************************************************************************************/

/*******************************************************************************************************
题目分析： 本题解法较为巧妙，将最大值找出，然后对arr1的每个元素出现的频率进行计算，放入数组中，
然后遍历arr2数组，对出现的每个元素与其频率结合，放入结果数组，然后从0开始直到最大值的所有数据进行遍历，
当其频率不为0的时候就将其放入结果数组 （因为从0开始向最大值遍历，所以解决了正常思路中需要排序的问题）。
********************************************************************************************************/

class Solution {
public:
    vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {
        //拿到数组中的最大值
        int upper = *max_element(arr1.begin(), arr1.end());
        vector<int> frequency(upper + 1);
        //计算每个元素出现的次数
        for (int x: arr1) 
        {
            ++frequency[x];
        }
        vector<int> ans;
        //外层循环遍历每个元素
        for (int x: arr2) 
        {
            //将每个元素按照出现频率放入新数组
            for (int i = 0; i < frequency[x]; ++i) 
            {
                ans.push_back(x);
            }
            //放入之后将其出现频率置为0
            frequency[x] = 0;
        }
        //将没有出现过的元素进行排序放入末尾，采用的是从0到最大值，按照出现频率放入最终数组
        for (int x = 0; x <= upper; ++x) 
        {
            for (int i = 0; i < frequency[x]; ++i) 
            {
                ans.push_back(x);
            }
        }
        return ans;
    }
};  
