// Source : https://leetcode-cn.com/problems/license-key-formatting/submissions/
// Date : 2021-11-20

/**************************************************************************************
有一个密钥字符串 S ，只包含字母，数字以及 ‘-’（破折号）。其中， N 个 ‘-’ 将字符串分成了 N+1 组。

给你一个数字 K，请你重新格式化字符串，使每个分组恰好包含 K 个字符。特别地，第一个分组包含的字符个数必须小于等于 K，但至少要包含 1 个字符。两个分组之间需要用 ‘-’（破折号）隔开，并且将所有的小写字母转换为大写字母。给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。

示例 1：

输入：S = “5F3Z-2e-9-w”, K = 4
输出：“5F3Z-2E9W”
解释：字符串 S 被分成了两个部分，每部分 4 个字符；
注意，两个额外的破折号需要删掉。
示例 2：

输入：S = “2-5g-3-J”, K = 2
输出：“2-5G-3J”
解释：字符串 S 被分成了 3 个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。

提示:
1.S 的长度可能很长，请按需分配大小。K 为正整数。
2.S 只包含字母数字（a-z，A-Z，0-9）以及破折号’-’
3.S 非空

**************************************************************************************/

/*******************************************************************************************************
题目分析：本方法从后向前遍历，需要注意的是，如果最后字符为 - ，则需要进行删除操作，因为代码采用计数器的方式来进行 - 的添加而不是遍历到一定次数来进行添加。
********************************************************************************************************/
class Solution {
public:
    string licenseKeyFormatting(string s, int k) {
        string ans;
        int cnt = 0;
        //从后向前遍历
        for (int i = s.size() - 1; i >= 0; i--) 
        {
            //如果当前字符不是-，则将其转为大写并加入目标字符串中 
            if (s[i] != '-') 
            {
                //所有字符转大写
                ans.push_back(toupper(s[i]));
                //计数器自增来给合适的地方添加 -
                cnt++;
                //此方法可以方便的使每个分组包含k个字符
                if (cnt % k == 0) 
                {
                    //一个分组结束，添加一个 -
                    ans.push_back('-');
                }
            }
        }
        //如果现在字符串末尾是 - ，则需要进行删除操作
        if (ans.size() > 0 && ans.back() == '-') 
        {
            //在字符串末尾删除一个字符
            ans.pop_back();
        }
        //将写好的字符串翻转
        reverse(ans.begin(), ans.end());
        
        return ans;
    }
};
