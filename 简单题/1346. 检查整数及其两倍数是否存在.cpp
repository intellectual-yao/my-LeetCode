// Source : https://leetcode-cn.com/problems/check-if-n-and-its-double-exist/
// Author : GuoQiang Yao
// Date : 2022-5-4

/**************************************************************************************
给你一个整数数组 arr，请你检查是否存在两个整数 N 和 M，满足 N 是 M 的两倍（即，N = 2 * M）。

更正式地，检查是否存在两个下标 i 和 j 满足：

i != j
0 <= i, j < arr.length
arr[i] == 2 * arr[j]

示例 1：

输入：arr = [10,2,5,3]
输出：true
解释：N = 10 是 M = 5 的两倍，即 10 = 2 * 5 。
示例 2：

输入：arr = [7,1,14,11]
输出：true
解释：N = 14 是 M = 7 的两倍，即 14 = 2 * 7 。
示例 3：

输入：arr = [3,1,7,11]
输出：false
解释：在该情况下不存在 N 和 M 满足 N = 2 * M 。

提示：

2 <= arr.length <= 500
-10^3 <= arr[i] <= 10^3

**************************************************************************************/

/*******************************************************************************************************
题目分析: 双重循环遍历即可解决本题，但是显然不是效率最高的解法，因为内层循环使用的是 i 之后的元素开始遍历，
那么就存在如果当前元素如果是最大的，那么显然不可能满足需求，因此需要加上如果第一个元素除以 2 也可以满足两倍的关系的话，
那么也符合题意。要注意的是，因为使用的是整数除法，那么就会存在相除以后小数的截断问题，因此除以2也好乘以2也好，应该写为2.0，而不是2，这样方可通过。
********************************************************************************************************/

class Solution {
public:
    bool checkIfExist(vector<int>& arr) {
        // 先对原数组进行排序
        // sort(arr.begin(), arr.end());
        for(int i = 0;i < arr.size();++i)
        {
            for(int j = i + 1;j < arr.size();++j)
            {
                // 因为除法不一定可以整除，因此需要将除数写成小数，避免自动截断问题
                if(arr[i] * 2.0 == arr[j] || arr[i] / 2.0 == arr[j])
                    return true;
            }
        }
        return false;
    }
}; 
