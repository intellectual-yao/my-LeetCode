// Source : https://leetcode-cn.com/problems/shortest-distance-to-a-character/
// Author : GuoQiang Yao
// Date : 2022-1-4

/**************************************************************************************
给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。

返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。

两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。

示例 1：

输入：s = “loveleetcode”, c = “e”
输出：[3,2,1,0,1,0,0,1,2,2,1,0]
解释：字符 ‘e’ 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。
距下标 0 最近的 ‘e’ 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。
距下标 1 最近的 ‘e’ 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。
对于下标 4 ，出现在下标 3 和下标 5 处的 ‘e’ 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。
距下标 8 最近的 ‘e’ 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。
示例 2：

输入：s = “aaab”, c = “b”
输出：[3,2,1,0]

提示：
1 <= s.length <= 104
s[i] 和 c 均为小写英文字母
题目数据保证 c 在 s 中至少出现一次

**************************************************************************************/

/*******************************************************************************************************
题目分析：首先将目标字符在原字符串中的下标利用下标数组进行存储，然后开始遍历原字符串，
当碰到目标字符串的时候首先将该处下标置为0，然后如果碰到的不是目标字符串，就遍历索引数组，
利用索引数组中存储的下标值减去当前字符的下标，然后继续进行遍历，需要注意的是，
如果当前计算出来的差值大于已经存在的数值，则直接用已经存在的差值即可，否则就用小的差值更新原有的值，
最后将结果数组进行返回即可。
********************************************************************************************************/

class Solution {
public:
    vector<int> shortestToChar(string S, char C) {
        int n = S.length();
        vector<int> c_indices;
        // Initialize a vector of size n with default value n.
        vector<int> res(n, n);

        //将目标字符的下标先放在索引数组中
        for (int i = 0; i < n; i++) 
        {
            if (S[i] == C) 
                c_indices.push_back(i);
        }

        for (int i = 0; i < n; i++) 
        {//目标字符的下标置为0
            if (S[i] == C) 
            {
                res[i] = 0;
                continue;
            }
            for (int j = 0; j < c_indices.size(); j++) 
            {
                int dist = abs(c_indices[j] - i);
                //如果距离大于已存在的距离，就退出，开始下一轮循环
                if (dist > res[i]) 
                    break;
                //否则用当前距离替代res数组中的距离
                res[i] = dist;
            }
        }
        return res;
    }
};
