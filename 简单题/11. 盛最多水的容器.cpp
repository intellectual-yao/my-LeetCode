// Source : https://leetcode.cn/problems/container-with-most-water/
// Author : GuoQiang Yao
// Date : 2022-5-14

/**************************************************************************************
给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。

找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

说明：你不能倾斜容器。

示例 1：
输入：[1,8,6,2,5,4,8,3,7]
输出：49
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
示例 2：

输入：height = [1,1]
输出：1

提示：

n == height.length
2 <= n <= 10^5
0 <= height[i] <= 10^4
**************************************************************************************/

/*******************************************************************************************************
题目分析：首先可以想到的就是将每两个的容积算出来然后找出最大的哪个容积即为最终答案，很显然，
这种方法会超时，因此就考虑使用双指针来进行解决，左右指针开始指向数组的首尾，然后计算对应的容积即可。
如果左指针对应的权重如果小于右指针权重，就将左指针右移，反正右指针左移即可。
********************************************************************************************************/

// 暴力法直接超时
// class Solution {
// public:
//     int maxArea(vector<int>& height) {
//         int res = 0;
//         for(int i = 0;i < height.size();++i)
//         {
//             for(int j = i + 1;j < height.size();++j)
//             {
//                 // 容积应该遵循木桶原则
//                 res = max(res, min(height[i], height[j]) * (j - i));
//             }
//         }
//         return res;
//     }
// };

// 转念一想使用双指针会不会好一些
class Solution{
    public:
        int maxArea(vector<int> &height){
            int res = 0;
            int i = 0, j = height.size() - 1;
            while(i < j)
            {
                res = max(res, min(height[i], height[j]) * (j - i));
                if(height[i] < height[j])
                    ++i;
                else
                    --j;
            }
            return res;
        }
}; 
