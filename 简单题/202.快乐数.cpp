// Source : https://leetcode-cn.com/problems/happy-number/submissions/
// Author : GuoQiang Yao
// Date : 2022-2-18

/**************************************************************************************
编写一个算法来判断一个数 n 是不是快乐数。
「快乐数」 定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果这个过程 结果为 1，
那么这个数就是快乐数。如果 n 是 快乐数 就返回 true ；不是，则返回 false 。


示例 1：

输入：n = 19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
示例 2：

输入：n = 2
输出：false

提示：

1 <= n <= 231 - 1

**************************************************************************************/

/*******************************************************************************************************
题目分析：首先，对于哈希法：我们将每次计算的结果保存进哈希表，如果出现了重复，则说明已经出现了循环，
那么此数字就一定不可能是快乐数；其次，对于快慢指针法：快指针每次要走两步，因此计算的时候需要计算两次，
然后拿到返回值，慢指针每次走一步，所以只需要计算一次即可，此方法主要的问题就是如何判断快慢指针相遇问题。
如果两个指针相遇即他们的值相同，那么此时我们认为进入死循环，否则我们判断slow指针是不是等于1，如果是1的话我们认为该数字属于快乐数
********************************************************************************************************/

// 哈希表+循环检测

class Solution {
public:
    bool isHappy(int n) {
        set<int> hash;
        while (n != 1) {
            hash.insert(n);   // 每次记录n(sum)的值
            int sum = 0;
            // 计算中间结果sum (n的每个数位上的数的平方的和)
            while (n) {
                sum += (n % 10) * (n % 10);
                n /= 10;
            }
            if (hash.find(sum) != hash.end())   // 若之前计算得到的sum与当前sum相同，说明出现循环，因此返回false
                return false;
            n = sum;          // sum做为n继续进行计算
        }
        return true;          // 若最终n=1退出循环，说明起初的n为快乐数，因此返回true
    }
};




// // 快慢指针

// class Solution {
// private:
//     int caculate(int n);  

// public:
//     bool isHappy(int n) {
//         int slow = n, fast = n;
//         do {
//             slow = caculate(slow);             // 对于slow每次运算一次
//             fast = caculate(caculate(fast));   // 对于fast每次运算两次
//         }while (slow != fast);     // (1)如果死循环，则 slow==fast 而退出循环，此时slow!=1; (2)如果是正常退出循环，则slow==fast==1，只不过fast更早等于1(caculate(1)=1)

//         return (1 == slow) ? true : false;     // 最终只要根据slow或fast的值，就可判断结果
//     }
// };

// int Solution::caculate(int n) {      // 计算n的"每个数位上的数的平方的和"
//     int sum = 0;
//     while (n) {
//         sum += (n % 10) * (n % 10);
//         n /= 10;
//     }

//     return sum;
// }
